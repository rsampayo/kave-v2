{
  "Console Log": {
    "prefix": "cl",
    "body": "console.log($1);",
    "description": "Console log statement"
  },
  "React Function Component": {
    "prefix": "rfc",
    "body": [
      "import React from 'react';",
      "",
      "interface ${1:ComponentName}Props {",
      "  $2",
      "}",
      "",
      "export const ${1:ComponentName}: React.FC<${1:ComponentName}Props> = ($3) => {",
      "  return (",
      "    <div>",
      "      $4",
      "    </div>",
      "  );",
      "};",
      ""
    ],
    "description": "Create a React Function Component with TypeScript"
  },
  "Try Catch": {
    "prefix": "tc",
    "body": [
      "try {",
      "  $1",
      "} catch (error) {",
      "  console.error('Error:', error);",
      "}"
    ],
    "description": "Try-catch block"
  },
  "FastAPI Route": {
    "prefix": "faroute",
    "body": [
      "from typing import List, Annotated",
      "from fastapi import APIRouter, Depends, HTTPException, status, Query",
      "from app.schemas.${1:domain} import ${2:Schema}",
      "from app.services.${1:domain} import ${3:Service}",
      "",
      "router = APIRouter(prefix=\"/${1:domain}\", tags=[\"${1:domain}\"])",
      "",
      "",
      "@router.get(\"/\", response_model=List[${2:Schema}])",
      "async def get_${1:domain}s(",
      "    service: Annotated[${3:Service}, Depends(${3:Service})],",
      "    skip: Annotated[int, Query(ge=0)] = 0,",
      "    limit: Annotated[int, Query(ge=1, le=100)] = 20,",
      "):",
      "    \"\"\"",
      "    Retrieve a list of ${1:domain}s.",
      "    ",
      "    Args:",
      "        service: The ${1:domain} service",
      "        skip: Number of records to skip",
      "        limit: Maximum number of records to return",
      "    ",
      "    Returns:",
      "        List of ${2:Schema} objects",
      "    \"\"\"",
      "    return await service.get_all(skip=skip, limit=limit)",
      ""
    ],
    "description": "Create a FastAPI router with basic CRUD endpoints"
  },
  "FastAPI Test": {
    "prefix": "fatest",
    "body": [
      "import pytest",
      "from httpx import AsyncClient",
      "from app.main import app",
      "",
      "",
      "@pytest.mark.asyncio",
      "async def test_${1:feature_name}():",
      "    # Arrange",
      "    ${2:test_data} = {",
      "        $3",
      "    }",
      "",
      "    # Act",
      "    async with AsyncClient(app=app, base_url=\"http://test\") as client:",
      "        response = await client.${4|get,post,put,delete|}(\"${5:/endpoint}\"${6:, json=test_data})",
      "",
      "    # Assert",
      "    assert response.status_code == ${7:200}",
      "    data = response.json()",
      "    $8"
    ],
    "description": "Create a FastAPI test following AAA pattern"
  },
  "Pydantic Model": {
    "prefix": "pydmodel",
    "body": [
      "from pydantic import BaseModel, Field",
      "from typing import Optional",
      "",
      "",
      "class ${1:ModelName}(BaseModel):",
      "    ${2:field}: ${3:str} = Field(description=\"${4:Field description}\")",
      "    ",
      "    model_config = {",
      "        \"json_schema_extra\": {",
      "            \"examples\": [",
      "                {",
      "                    \"${2:field}\": \"${5:example value}\"",
      "                }",
      "            ]",
      "        }",
      "    }",
      ""
    ],
    "description": "Create a Pydantic v2 model with Field and example"
  },
  "Service Class": {
    "prefix": "faservice",
    "body": [
      "from typing import List, Optional",
      "from fastapi import HTTPException, status, Depends",
      "from sqlalchemy import select",
      "from sqlalchemy.ext.asyncio import AsyncSession",
      "from app.models.${1:model} import ${2:Model}",
      "from app.schemas.${1:model} import ${3:Schema}",
      "from app.db.session import get_db",
      "",
      "",
      "class ${4:Service}:",
      "    def __init__(self, db: AsyncSession = Depends(get_db)):",
      "        self.db = db",
      "",
      "    async def get_all(self, skip: int = 0, limit: int = 100) -> List[${3:Schema}]:",
      "        result = await self.db.execute(",
      "            select(${2:Model}).offset(skip).limit(limit)",
      "        )",
      "        items = result.scalars().all()",
      "        return [${3:Schema}.model_validate(item) for item in items]",
      "",
      "    async def get_by_id(self, id: int) -> ${3:Schema}:",
      "        result = await self.db.execute(",
      "            select(${2:Model}).filter(${2:Model}.id == id)",
      "        )",
      "        item = result.scalars().first()",
      "        if not item:",
      "            raise HTTPException(",
      "                status_code=status.HTTP_404_NOT_FOUND,",
      "                detail=f\"${2:Model} with id {id} not found\"",
      "            )",
      "        return ${3:Schema}.model_validate(item)",
      ""
    ],
    "description": "Create a FastAPI service class with basic CRUD operations using SQLAlchemy 2.0"
  },
  "SQLAlchemy Model": {
    "prefix": "sqlmodel",
    "body": [
      "from sqlalchemy import Column, Integer, String, ForeignKey, Boolean, DateTime",
      "from sqlalchemy.orm import relationship",
      "from sqlalchemy.sql import func",
      "from app.db.base_class import Base",
      "",
      "",
      "class ${1:ModelName}(Base):",
      "    __tablename__ = \"${2:table_name}\"",
      "",
      "    id = Column(Integer, primary_key=True, index=True)",
      "    ${3:field} = Column(${4:String}, ${5:nullable=False})",
      "    created_at = Column(DateTime(timezone=True), server_default=func.now())",
      "    updated_at = Column(",
      "        DateTime(timezone=True), server_default=func.now(), onupdate=func.now()",
      "    )",
      "",
      "    def __repr__(self):",
      "        return f\"<${1:ModelName} {self.id}>\""
    ],
    "description": "Create a SQLAlchemy 2.0 model"
  },
  "Alembic Revision": {
    "prefix": "alembicrev",
    "body": [
      "\"\"\"${1:migration_description}",
      "",
      "Revision ID: ${2:revision_id}",
      "\"\"\"",
      "from alembic import op",
      "import sqlalchemy as sa",
      "",
      "",
      "def upgrade() -> None:",
      "    ${3:# Add upgrade operations here}",
      "",
      "",
      "def downgrade() -> None:",
      "    ${4:# Add downgrade operations here}"
    ],
    "description": "Create an Alembic migration revision"
  },
  "Environment Settings": {
    "prefix": "envsettings",
    "body": [
      "from pydantic_settings import BaseSettings, SettingsConfigDict",
      "from pydantic import PostgresDsn, computed_field",
      "from typing import Optional, Dict, Any",
      "",
      "",
      "class Settings(BaseSettings):",
      "    PROJECT_NAME: str = \"${1:project_name}\"",
      "    VERSION: str = \"0.1.0\"",
      "    API_V1_STR: str = \"/api/v1\"",
      "",
      "    # Database settings",
      "    POSTGRES_SERVER: str = \"localhost\"",
      "    POSTGRES_USER: str = \"postgres\"",
      "    POSTGRES_PASSWORD: str = \"postgres\"",
      "    POSTGRES_DB: str = \"${1:project_name}\"",
      "    DATABASE_URI: Optional[PostgresDsn] = None",
      "",
      "    @computed_field",
      "    @property",
      "    def SQLALCHEMY_DATABASE_URI(self) -> str:",
      "        if self.DATABASE_URI:",
      "            return str(self.DATABASE_URI)",
      "        return PostgresDsn.build(",
      "            scheme=\"postgresql+asyncpg\",",
      "            username=self.POSTGRES_USER,",
      "            password=self.POSTGRES_PASSWORD,",
      "            host=self.POSTGRES_SERVER,",
      "            path=f\"/{self.POSTGRES_DB}\"",
      "        )",
      "",
      "    model_config = SettingsConfigDict(",
      "        case_sensitive=True,",
      "        env_file=\".env\",",
      "        env_file_encoding=\"utf-8\",",
      "    )",
      ""
    ],
    "description": "Create a Pydantic V2 Settings class for environment configuration"
  },
  "FastAPI Dependency": {
    "prefix": "fadep",
    "body": [
      "from typing import AsyncGenerator, Annotated",
      "from fastapi import Depends",
      "from sqlalchemy.ext.asyncio import AsyncSession",
      "from app.db.session import async_session_factory",
      "from app.services.${1:service} import ${2:Service}",
      "",
      "",
      "async def get_db() -> AsyncGenerator[AsyncSession, None]:",
      "    async with async_session_factory() as session:",
      "        try:",
      "            yield session",
      "            await session.commit()",
      "        except Exception:",
      "            await session.rollback()",
      "            raise",
      "",
      "",
      "def get_${3:service_name}(",
      "    db: Annotated[AsyncSession, Depends(get_db)]",
      ") -> ${2:Service}:",
      "    return ${2:Service}(db)",
      ""
    ],
    "description": "Create FastAPI dependency injection functions with SQLAlchemy 2.0 async support"
  },
  "FastAPI App": {
    "prefix": "faapp",
    "body": [
      "from fastapi import FastAPI",
      "from fastapi.middleware.cors import CORSMiddleware",
      "from contextlib import asynccontextmanager",
      "from app.core.config import settings",
      "from app.api.api_v1.api import api_router",
      "from app.core.exceptions import DomainException, domain_exception_handler",
      "from fastapi.exceptions import RequestValidationError",
      "from app.core.exceptions import validation_exception_handler",
      "",
      "",
      "@asynccontextmanager",
      "async def lifespan(app: FastAPI):",
      "    # Startup logic (database connections, etc.)",
      "    yield",
      "    # Shutdown logic (close connections, etc.)",
      "",
      "",
      "app = FastAPI(",
      "    title=settings.PROJECT_NAME,",
      "    version=settings.VERSION,",
      "    openapi_url=f\"{settings.API_V1_STR}/openapi.json\",",
      "    docs_url=f\"{settings.API_V1_STR}/docs\",",
      "    redoc_url=f\"{settings.API_V1_STR}/redoc\",",
      "    lifespan=lifespan,",
      ")",
      "",
      "# Set up CORS",
      "origins = [",
      "    \"http://localhost\",",
      "    \"http://localhost:8080\",",
      "    \"http://localhost:3000\",",
      "]",
      "",
      "app.add_middleware(",
      "    CORSMiddleware,",
      "    allow_origins=origins,",
      "    allow_credentials=True,",
      "    allow_methods=[\"*\"],",
      "    allow_headers=[\"*\"],",
      ")",
      "",
      "# Add exception handlers",
      "app.add_exception_handler(DomainException, domain_exception_handler)",
      "app.add_exception_handler(RequestValidationError, validation_exception_handler)",
      "",
      "# Add routers",
      "app.include_router(api_router, prefix=settings.API_V1_STR)",
      "",
      "@app.get(\"/health\", tags=[\"health\"])",
      "async def health_check():",
      "    return {\"status\": \"ok\"}",
      ""
    ],
    "description": "Create a FastAPI app with middleware and exception handlers using lifespan for startup/shutdown"
  },
  "Custom Exception": {
    "prefix": "faexception",
    "body": [
      "from fastapi import Request, status",
      "from fastapi.responses import JSONResponse",
      "from fastapi.exceptions import RequestValidationError",
      "",
      "",
      "class ${1:Domain}Exception(Exception):",
      "    def __init__(self, detail: str, status_code: int = 400):",
      "        self.detail = detail",
      "        self.status_code = status_code",
      "",
      "",
      "async def ${2:domain}_exception_handler(request: Request, exc: ${1:Domain}Exception):",
      "    return JSONResponse(",
      "        status_code=exc.status_code,",
      "        content={\"detail\": exc.detail},",
      "    )",
      "",
      "",
      "async def validation_exception_handler(request: Request, exc: RequestValidationError):",
      "    return JSONResponse(",
      "        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,",
      "        content={\"detail\": exc.errors()},",
      "    )"
    ],
    "description": "Create a custom exception and handlers for FastAPI"
  },
  "FastAPI Environment DB": {
    "prefix": "faenvdb",
    "body": [
      "import os",
      "from typing import Optional",
      "from pydantic_settings import BaseSettings, SettingsConfigDict",
      "from pydantic import computed_field",
      "",
      "",
      "class Settings(BaseSettings):",
      "    # App settings",
      "    PROJECT_NAME: str = \"${1:project_name}\"",
      "    VERSION: str = \"0.1.0\"",
      "    API_V1_STR: str = \"/api/v1\"",
      "    ",
      "    # Database configuration",
      "    DATABASE_URL: Optional[str] = None",
      "    ",
      "    @computed_field",
      "    @property",
      "    def SQLALCHEMY_DATABASE_URI(self) -> str:",
      "        \"\"\"Database URI to use based on environment\"\"\"",
      "        if self.DATABASE_URL:",
      "            # Use PostgreSQL in Heroku",
      "            return self.DATABASE_URL",
      "        # Use SQLite for local development",
      "        return \"sqlite+aiosqlite:///./dev.db\"",
      "    ",
      "    @computed_field",
      "    @property",
      "    def TEST_DATABASE_URI(self) -> str:",
      "        \"\"\"Get database URL based on environment\"\"\"",
      "        if self.DATABASE_URL:",
      "            # Use temporary schema in Heroku's Postgres",
      "            return f\"{self.DATABASE_URL}_test\"",
      "        # Use SQLite for local testing",
      "        return \"sqlite+aiosqlite:///./test.db\"",
      "    ",
      "    model_config = SettingsConfigDict(",
      "        case_sensitive=True,",
      "        env_file=\".env\",",
      "        env_file_encoding=\"utf-8\",",
      "    )",
      "",
      "settings = Settings()",
      ""
    ],
    "description": "Create environment-aware database configuration that switches between SQLite and PostgreSQL using Pydantic v2"
  },
  "GitHub Actions Workflow": {
    "prefix": "fagithub",
    "body": [
      "name: FastAPI CI/CD",
      "",
      "on:",
      "  push:",
      "    branches: [ main, develop ]",
      "  pull_request:",
      "    branches: [ main, develop ]",
      "",
      "jobs:",
      "  quality:",
      "    name: Code Quality",
      "    runs-on: ubuntu-latest",
      "    steps:",
      "      - uses: actions/checkout@v4",
      "      - name: Set up Python",
      "        uses: actions/setup-python@v5",
      "        with:",
      "          python-version: '3.12'",
      "          cache: 'pip'",
      "      - name: Install dependencies",
      "        run: |",
      "          python -m pip install --upgrade pip",
      "          pip install black isort flake8 flake8-bugbear flake8-docstrings flake8-comprehensions mypy",
      "          pip install -r requirements.txt",
      "      - name: Run quality checks",
      "        run: | ",
      "          black --check .",
      "          isort --check .",
      "          flake8 .",
      "          mypy .",
      "",
      "  test:",
      "    name: Run Test Suite",
      "    needs: quality",
      "    runs-on: ubuntu-latest",
      "    services:",
      "      postgres:",
      "        image: postgres:16-alpine",
      "        env:",
      "          POSTGRES_USER: postgres",
      "          POSTGRES_PASSWORD: postgres",
      "          POSTGRES_DB: test_db",
      "        ports:",
      "          - 5432:5432",
      "        options: >-",
      "          --health-cmd pg_isready",
      "          --health-interval 10s",
      "          --health-timeout 5s",
      "          --health-retries 5",
      "    steps:",
      "      - uses: actions/checkout@v4",
      "      - name: Set up Python",
      "        uses: actions/setup-python@v5",
      "        with:",
      "          python-version: '3.12'",
      "          cache: 'pip'",
      "      - name: Install dependencies",
      "        run: |",
      "          python -m pip install --upgrade pip",
      "          pip install -r requirements.txt",
      "          pip install pytest pytest-cov pytest-asyncio",
      "      - name: Run tests with coverage",
      "        run: pytest --cov=app --cov-report=xml --cov-report=term --cov-fail-under=90",
      "        env:",
      "          DATABASE_URL: postgresql+asyncpg://postgres:postgres@localhost:5432/test_db",
      ""
    ],
    "description": "Create a GitHub Actions workflow for FastAPI CI/CD with PostgreSQL 16"
  },
  "Pytest Conftest": {
    "prefix": "faconftest",
    "body": [
      "import pytest",
      "import asyncio",
      "from typing import AsyncGenerator, Generator",
      "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine",
      "from sqlalchemy.orm import sessionmaker",
      "from httpx import AsyncClient",
      "from app.main import app",
      "from app.db.base import Base",
      "from app.core.config import settings",
      "from app.api.deps import get_db",
      "",
      "# Create test database engine",
      "test_engine = create_async_engine(settings.TEST_DATABASE_URI, echo=False)",
      "TestAsyncSessionFactory = sessionmaker(",
      "    test_engine, class_=AsyncSession, expire_on_commit=False",
      ")",
      "",
      "",
      "@pytest.fixture(scope=\"session\")",
      "def event_loop() -> Generator[asyncio.AbstractEventLoop, None, None]:",
      "    \"\"\"Create an instance of the default event loop for each test case.\"\"\"",
      "    loop = asyncio.get_event_loop_policy().new_event_loop()",
      "    yield loop",
      "    loop.close()",
      "",
      "",
      "@pytest.fixture(scope=\"session\")",
      "async def setup_test_db() -> AsyncGenerator[None, None]:",
      "    # Create tables",
      "    async with test_engine.begin() as conn:",
      "        await conn.run_sync(Base.metadata.create_all)",
      "    ",
      "    yield",
      "    ",
      "    # Drop tables after tests",
      "    async with test_engine.begin() as conn:",
      "        await conn.run_sync(Base.metadata.drop_all)",
      "",
      "",
      "@pytest.fixture(scope=\"function\")",
      "async def db() -> AsyncGenerator[AsyncSession, None]:",
      "    async with test_engine.begin() as connection:",
      "        async with TestAsyncSessionFactory(bind=connection) as session:",
      "            # Start with a clean slate for each test",
      "            for table in reversed(Base.metadata.sorted_tables):",
      "                await session.execute(table.delete())",
      "            ",
      "            yield session",
      "",
      "",
      "@pytest.fixture(scope=\"function\")",
      "async def client(",
      "    db: AsyncSession, setup_test_db: None",
      ") -> AsyncGenerator[AsyncClient, None]:",
      "    # Override dependency",
      "    async def override_get_db() -> AsyncGenerator[AsyncSession, None]:",
      "        yield db",
      "    ",
      "    app.dependency_overrides[get_db] = override_get_db",
      "    ",
      "    async with AsyncClient(",
      "        app=app, base_url=\"http://test\", follow_redirects=True",
      "    ) as client:",
      "        yield client",
      "    ",
      "    app.dependency_overrides = {}"
    ],
    "description": "Create a pytest conftest.py file with database fixtures for FastAPI with SQLAlchemy 2.0 async"
  },
  "Async SQLAlchemy Session": {
    "prefix": "fasqlasession",
    "body": [
      "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker",
      "from typing import AsyncGenerator",
      "from app.core.config import settings",
      "",
      "# Create an async engine for the specified database URI",
      "engine = create_async_engine(",
      "    settings.SQLALCHEMY_DATABASE_URI,",
      "    pool_pre_ping=True,  # Enable connection health checks",
      "    echo=False,  # Set to True for SQL query logging",
      ")",
      "",
      "# Create a session factory for producing AsyncSession instances",
      "async_session_factory = async_sessionmaker(",
      "    engine,",
      "    class_=AsyncSession,",
      "    expire_on_commit=False,",
      "    autocommit=False,",
      "    autoflush=False,",
      ")",
      "",
      "",
      "async def get_db() -> AsyncGenerator[AsyncSession, None]:",
      "    \"\"\"",
      "    Dependency that yields async DB sessions.",
      "    ",
      "    Yields:",
      "        AsyncSession: SQLAlchemy async session",
      "    \"\"\"",
      "    async with async_session_factory() as session:",
      "        try:",
      "            yield session",
      "            await session.commit()",
      "        except Exception:",
      "            await session.rollback()",
      "            raise",
      ""
    ],
    "description": "Create SQLAlchemy 2.0 async session configuration"
  },
  "SQLAlchemy Base Class": {
    "prefix": "fasqlbase",
    "body": [
      "from sqlalchemy.ext.declarative import declared_attr",
      "from sqlalchemy.orm import DeclarativeBase",
      "from sqlalchemy import Column, Integer, DateTime",
      "from sqlalchemy.sql import func",
      "from typing import Any",
      "",
      "",
      "class Base(DeclarativeBase):",
      "    \"\"\"Base class for all SQLAlchemy models\"\"\"",
      "    id: Any",
      "    __name__: str",
      "    ",
      "    # Generate __tablename__ automatically",
      "    @declared_attr.directive",
      "    def __tablename__(cls) -> str:",
      "        return cls.__name__.lower()",
      "",
      "",
      "class TimestampMixin:",
      "    \"\"\"Mixin to add timestamp columns to models\"\"\"",
      "    created_at = Column(DateTime(timezone=True), server_default=func.now())",
      "    updated_at = Column(",
      "        DateTime(timezone=True), server_default=func.now(), onupdate=func.now()",
      "    )",
      ""
    ],
    "description": "Create a SQLAlchemy 2.0 base model class"
  },
  "SQLAlchemy CRUD Base": {
    "prefix": "fasqlcrud",
    "body": [
      "from typing import Any, Dict, Generic, List, Optional, Type, TypeVar, Union",
      "from fastapi.encoders import jsonable_encoder",
      "from pydantic import BaseModel",
      "from sqlalchemy import select, update, delete",
      "from sqlalchemy.ext.asyncio import AsyncSession",
      "from app.db.base_class import Base",
      "",
      "",
      "ModelType = TypeVar(\"ModelType\", bound=Base)",
      "CreateSchemaType = TypeVar(\"CreateSchemaType\", bound=BaseModel)",
      "UpdateSchemaType = TypeVar(\"UpdateSchemaType\", bound=BaseModel)",
      "",
      "",
      "class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):",
      "    def __init__(self, model: Type[ModelType]):",
      "        \"\"\"",
      "        CRUD base class with default methods to Create, Read, Update, Delete (CRUD).",
      "        ",
      "        Args:",
      "            model: A SQLAlchemy model class",
      "        \"\"\"",
      "        self.model = model",
      "    ",
      "    async def get(self, db: AsyncSession, id: Any) -> Optional[ModelType]:",
      "        \"\"\"",
      "        Get a record by ID.",
      "        ",
      "        Args:",
      "            db: Database session",
      "            id: ID of the record to get",
      "            ",
      "        Returns:",
      "            The record or None if not found",
      "        \"\"\"",
      "        result = await db.execute(select(self.model).filter(self.model.id == id))",
      "        return result.scalars().first()",
      "    ",
      "    async def get_multi(",
      "        self, db: AsyncSession, *, skip: int = 0, limit: int = 100",
      "    ) -> List[ModelType]:",
      "        \"\"\"",
      "        Get multiple records.",
      "        ",
      "        Args:",
      "            db: Database session",
      "            skip: Number of records to skip",
      "            limit: Maximum number of records to get",
      "            ",
      "        Returns:",
      "            List of records",
      "        \"\"\"",
      "        result = await db.execute(",
      "            select(self.model).offset(skip).limit(limit)",
      "        )",
      "        return result.scalars().all()",
      "    ",
      "    async def create(self, db: AsyncSession, *, obj_in: CreateSchemaType) -> ModelType:",
      "        \"\"\"",
      "        Create a new record.",
      "        ",
      "        Args:",
      "            db: Database session",
      "            obj_in: Schema with create data",
      "            ",
      "        Returns:",
      "            The created record",
      "        \"\"\"",
      "        obj_in_data = jsonable_encoder(obj_in)",
      "        db_obj = self.model(**obj_in_data)  # type: ignore",
      "        db.add(db_obj)",
      "        await db.commit()",
      "        await db.refresh(db_obj)",
      "        return db_obj",
      "    ",
      "    async def update(",
      "        self,",
      "        db: AsyncSession,",
      "        *,",
      "        db_obj: ModelType,",
      "        obj_in: Union[UpdateSchemaType, Dict[str, Any]]",
      "    ) -> ModelType:",
      "        \"\"\"",
      "        Update a record.",
      "        ",
      "        Args:",
      "            db: Database session",
      "            db_obj: The database object to update",
      "            obj_in: New data to update with",
      "            ",
      "        Returns:",
      "            The updated record",
      "        \"\"\"",
      "        obj_data = jsonable_encoder(db_obj)",
      "        if isinstance(obj_in, dict):",
      "            update_data = obj_in",
      "        else:",
      "            update_data = obj_in.model_dump(exclude_unset=True)",
      "        ",
      "        for field in obj_data:",
      "            if field in update_data:",
      "                setattr(db_obj, field, update_data[field])",
      "        ",
      "        db.add(db_obj)",
      "        await db.commit()",
      "        await db.refresh(db_obj)",
      "        return db_obj",
      "    ",
      "    async def remove(self, db: AsyncSession, *, id: int) -> ModelType:",
      "        \"\"\"",
      "        Remove a record.",
      "        ",
      "        Args:",
      "            db: Database session",
      "            id: ID of the record to remove",
      "            ",
      "        Returns:",
      "            The removed record",
      "        \"\"\"",
      "        obj = await self.get(db=db, id=id)",
      "        await db.delete(obj)",
      "        await db.commit()",
      "        return obj",
      ""
    ],
    "description": "Create a base CRUD class for SQLAlchemy 2.0 models with async operations"
  }
}
